---
title: 树的相关算法以及树转换为二叉树
date: 2016-03-17 09:36:36
categories: 算法
description: 常见算法复杂度；复杂度；算法；树转换为二叉树
tags: 
- 算法
- 复杂度
- 二叉树
- 面试
- 树

---

# 树的相关算法以及树转换为二叉树

![树与二叉树](https://upload.wikimedia.org/wikipedia/commons/0/02/Nary_to_binary_tree_conversion.png)

## 树的相关概念

**二叉树** Binary Tree

每个节点可有左右区分的两个子节点(子树)；节点的值**可能相同**(代码中不能根据值判断是否为同一个节点)；

**二叉排序树** Binary Search Tree

在二叉树的基础上，本节点的值必定大于左子树，小于右子树；所有节点的值**都不相同**；

**完全二叉树**

二叉树的基础上，树的每一行都是满的(2^(k-1)个节点在第k行)，除了最后一行。最后一行的节点从左到右是满的。

**满二叉树**

二叉树的基础上，树的每一行都是满的(2^(k-1)个节点在第k行)。

**平衡二叉树**

二叉树中，每个节点左右两个子树的高度差不超过1.

## 树转换为二叉树

很简单，每个节点的最左边的儿子还是儿子，其他儿子变成这个儿子的孙子、曾孙子等，可以递归进行：

```
struct Node
{
  int val;
  int childrenNum;
  Node** children;
  void addChild(Node* n)
  {
    children[childrenNum++] = n;
  }
};

void transfer(Node* root)
{
  if (root == NULL)
    return;
    
  for (int i = 0; i < root->childrenNum; i++)
  {
    transfer(root->children[i]); // 注意：必须先执行子节点的变换
    if (i != 0)
      root->children[i - 1]->addChild(root->children[i]);
  }
  
  root->childrenNum = root->childrenNum == 0 ? 0 : 1;
}
```

## 树的其他常见算法

### 最低公共祖先节点 Lowest Common Ancesters (LCA)

#### 排序二叉树

在二叉排序树中，如果两个节点的某个公共父节点的值在两个节点值之间，那么这个节点必然是两个节点的最低公共祖先。

也就是说，**在两个节点的所有公共祖先节点中，只有最低公共祖先节点的值在两者之间**。

利用这个结论，可以快速的在BST(Binary Search Tree)中找到两个节点值p与q的LCA(p < q)。

```
while (node)
{
  if (p < node->val && q < node->val)
  {
    node = node->left;
    continue;
  }
  if (p > node->val && q > node->val)
  {
    node = node->right;
    continue;
  }
  
  if (p < node->val && q > node->val)
    return node; // 找到LCA
}

```

#### 普通二叉树

首先，在普通二叉树中没有二叉搜索树的规律，因此可以使用递归进行运算。

通常情况下我们会构造递归函数，目的是返回子树中p与q的LCA，否则返回NULL。

但问题来了，如果节点左右子节点都为NULL，如何判断当前节点是否是p与q的LCA？

所以可以让递归函数返回子树中是否包含p与q，那么就可以判断出当前节点是否是LCA了。

```
TreeNode* lowestCommonAncestorHelper(TreeNode* root, TreeNode* p, TreeNode* q, bool & cp, bool & cq) {
    if (root == NULL)
    {
        cp = false;
        cq = false;
        return NULL;
    }
    
    bool lcp(false), lcq(false), rcp(false), rcq(false);
    TreeNode* ln = lowestCommonAncestorHelper(root->left, p, q, lcp, lcq);
    if (lcp && lcq)
    {
        cp = true;
        cq = true;
        return ln;
    }
    TreeNode* rn = lowestCommonAncestorHelper(root->right, p, q, rcp, rcq);
    if (rcp && rcq)
    {
        cp = true;
        cq = true;
        return rn;
    }
    
    cp = lcp || rcp || (root == p); // 注意：！普通的二叉树可能不是二叉搜索树(BST)，所以树节点的值可能重复
    cq = lcq || rcq || (root == q);
    if ( cp && cq )
        return root;
    
    return NULL;
}
```

### 树的左右对称交换

使用递归，左右交换即可。

```
void reverse(Node * root)
{
  if (root == NULL)
    return;
    
  swap(root->left, root->right); // swap和下面reverse的顺序可以调换
  reverse(root->left);
  reverse(root->right);
}
```

#### 类似题目

**对称交换二进制**

使用二分法左右交换。

```
void inverseBinary(int &bin)
{
	bin = ((0x0000FFFF & bin) << 16) | ( (0xFFFF0000 & bin) >> 16);
	bin = ((0x00FF00FF & bin) << 8 ) | ( (0xFF00FF00 & bin) >> 8);
	bin = ((0x0F0F0F0F & bin) << 4 ) | ( (0xF0F0F0F0 & bin) >> 4);
	bin = ((0x33333333 & bin) << 2 ) | ( (0xCCCCCCCC & bin) >> 2);
	bin = ((0x55555555 & bin) << 1 ) | ( (0xAAAAAAAA & bin) >> 1);
}
```

**对称交换字符串**

使用左右两个指针中间移动交换即可。

## 深度优先搜索(DFS)与广度优先搜索(BFS)

深度优先搜索使用Stack递归即可，而广度优先搜索需要使用队列(deque).

## 参考资料

* [WIKI二元搜尋樹](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9)