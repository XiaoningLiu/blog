{"meta":{"title":"刘晓宁的博客","subtitle":"Let's run for a walk!","description":"归纳，整理，创新 刘晓宁的博客 程序员健康指南 思考 反思","author":"刘晓宁","url":"http://xiaoningliu.com"},"pages":[{"title":"个人简介","date":"2016-03-11T15:03:56.000Z","updated":"2016-03-11T15:10:37.000Z","comments":true,"path":"aboutme/index.html","permalink":"http://xiaoningliu.com/aboutme/index.html","excerpt":"","text":"刘晓宁工作经历微软摩根项目经历尼艾航聚惠家科研人"}],"posts":[{"title":"severless 无服务架构简析5 - Serverless业界发展与应用","slug":"severless5","date":"2017-01-07T16:45:01.000Z","updated":"2017-01-07T17:03:59.000Z","comments":true,"path":"2017/01/08/severless5/","link":"","permalink":"http://xiaoningliu.com/2017/01/08/severless5/","excerpt":"","text":"亚马逊AWS Lambda这种框架在2014年AWS re:Invent大会上宣布，它是如今市面上最早、最成熟、稳定的serverless框架之一。这项服务最初支持Node.js，现在支持Java和Python。十多项AWS服务与Lambda集成起来，而且名单只会越来越长。移动和物联网开发人员之所以喜欢Lambda，是由于它带来了强大功能和灵活性。它与Alexa Skills Kit紧密集成，成为在为Amazon Echo开发语音激发的应用程序的开发人员当中最受青睐的平台。亚马逊提供交互式控制台和命令行工具，以便上传和管理代码片段。 Microsoft Azure Functions 在2016年4月份举行的Build大会上，微软宣布了Azure Functions预览版，这是一个根据需求运行代码的服务。Azure Functions意味着微软已经进入日益流行的、由Amazon、 Google、IBM等主导的事件驱动无服务器计算领域。Azure Functions让开发人员可以发布基于外部触发执行的代码，而不用考虑准备计算或存储资源。这些函数——使用C#、JavaScript、Bash、F#、PHP、PowerShell或PHP编写——通常表现为短期异步任务。在一篇有关预览版发布的博文中，微软将“数据处理”作为发布这类服务的一个重要原因。 FaceBook ParseParse是一个完整的 iOS,android 后端支持平台，它可以让开发者完成忘掉服务器端的事情，包含了 schema free 的数据存储和云代码（CloudCode）。其数据存储服务涵盖了结构化的对象存储和非结构化的文件存储（也包括 CDN），并且，Parse 提供了完善的账户系统和数据访问控制，而且提供了强大的数据关联（一对一、一对多、多对多等）和查询能力。除此之外，由于定位于通用的后台服务，所以在标准化 API 之外，Parse 也提供了方法让开发者可以定制自己的商业逻辑。他们的做法是建立一个 node.js 容器，让开发者使用 javascript 这种广为人知的前端语言来完成数据整合、计算，再将结果返回给客户端。具体如下图所示： Google Cloud Functions谷歌站在微服务模式的最前沿。除了有力推动Kubernetes外，这家公司还投资于AWS Lambda竞争对手：Cloud Functions，该架构可在其公共云基础设施上运行。不过Google Cloud Functions仍处于初期预览阶段，作为在谷歌计算引擎（Google Compute Engine）上运行的容器来托管。该平台只支持Node.js，不过预计在将来会添加更多的语言。只有几项服务与Cloud Functions进行了集成，比如Google Cloud Storage和Google Cloud Pub/Sub。考虑到谷歌API的覆盖面颇为广泛，该支持会支持另外多项服务，比如Gmail、Cloud Messaging、Maps及其他服务。 Iron.io虽然Iron.io从不以serverless computing平台的姿态示人，但是自2012年以来它就支持这种概念和框架。其中一些早期产品（比如IronQueue、IronWorker和IronCache）鼓励开发人员拿来代码后，即可在公共云中托管的Iron.io管理型平台中运行。最近，Iron.io拥抱Docker，并集成现有的服务，提供一种连贯完整的微服务平台。Iron.io的serverless computing平台其代号为Project Kratos，旨在将AWS Lambda引入到企业，又没有厂商锁定现象。Project Kratos可以在包括公共云和私有云在内的多个环境下，运行包装成Docker容器的现有AWS Lambda功能。 IBM OpenWhisIBM OpenWhisk在最近的InterConnect大会上宣布，这是一种可替代AWS Lambda的开源框架。除了支持Node.js外，OpenWhisk还可以运行用Swift编写的代码片段。该服务在将来可能会支持更多的语言。这种框架最出色的地方在于，开发人员可以将它安装在运行Ubuntu的本地机器上。Mac OS X和Windows开发人员可以使用Vagrant设备，将它安装并运行起来。该服务与IBM Bluemix即基于CloudFoundry的PaaS环境集成起来。除了可以调用Bluemix服务外，该框架还可与支持Webhook的任何第三方服务集成起来。开发人员可以使用CLI来管理OpenWhisk框架。 Serverless Framework虽然Serverless不是一种独立框架，但旨在简化开发和部署AWS Lambda应用程序的工作。这种开源框架最初名为JAWS，一亮相就引起了开发人员的关注。亚马逊邀请开发人员在上一届re:Invent大会上展示该框架。Serverless作为node.js NPM模块来提供，填补了AWS Lambda存在的许多缺口。它提供了多个样板模板，可以迅速启动AWS Lambda的开发。借助诸多插件，这种框架让用户很容易将AWS服务与其他第三方服务集成起来。 系列总结 云已经并将继续是IT基础设施和软件开发中的重要游戏规则。软件开发人员需要考虑他们如何最大限度地利用云平台来获得竞争优势。 Serverless架构是开发人员和组织思考，研究和采用的最新进展。随着开发人员接受AWS Lambda等计算服务，这将是一个令人兴奋的架构新转变。今天有无服务器应用程序，支持数千用户和执行复杂的操作，其中包括重要任务，如视频编码和数据处理等。在许多情况下，无服务器架构可以比传统模型实现更好的结果，并且实现起来更便宜，更快。 还需要降低与运行基础设施和开展传统软件系统相关的复杂性和成本。减少基础架构维护所需的成本和时间以及可扩展性的好处是组织和开发人员考虑无服务器架构的理由。在未来几年内，推送无服务器后端可能会加速。 在本系列中，我们了解了什么是无服务器架构，并与传统架构进行比较。我们研究了核心原则，并考虑了与这种架构相关的一些挑战。","categories":[{"name":"架构","slug":"架构","permalink":"http://xiaoningliu.com/categories/架构/"}],"tags":[{"name":"severless","slug":"severless","permalink":"http://xiaoningliu.com/tags/severless/"},{"name":"无服务","slug":"无服务","permalink":"http://xiaoningliu.com/tags/无服务/"},{"name":"无服务架构","slug":"无服务架构","permalink":"http://xiaoningliu.com/tags/无服务架构/"},{"name":"function","slug":"function","permalink":"http://xiaoningliu.com/tags/function/"}]},{"title":"severless 无服务架构简析4 - 应用场景分析","slug":"severless4","date":"2017-01-07T16:40:01.000Z","updated":"2017-01-07T17:03:15.000Z","comments":true,"path":"2017/01/08/severless4/","link":"","permalink":"http://xiaoningliu.com/2017/01/08/severless4/","excerpt":"","text":"无服务器架构允许开发人员专注于软件设计和代码，而不是基础设施。可扩展性和高可用性更容易实现，并且定价通常更公平，因为只为使用的资源支付。重要的是，对于无Serverless，可以通过最小化您需要的层和代码的数量来减少系统的一些复杂性。 低频请求场景物联网行业中，由于物联网设备传输数据量小，且往往是固定时间间隔进行数据传输，因此经常涉及低频请求场景。例如：物联网应用程序每分钟仅运行一次，每次运行50ms，这意味着CPU的使用率为0.1%/小时，这也意味着其实有1000个相同的应用可以共享计算资源。而Serverless架构下，用户可以购买每分钟100ms的资源来满足计算需求，通过这种方式就能够有效解决效率问题，降低使用成本。 流量突发场景移动互联网应用经常会面对突发流量场景，例如：移动应用的通常流量情况是QPS 20，但每隔五分钟会有一个持续10s的QPS 200流量（10倍于通常流量），传统架构下企业必须扩展QPS 200的硬件能力来应对业务高峰，即使高峰时间仅占整个运行时间的4%；而在Serverless架构下，用户可以利用弹性扩展特性，快速构建新的计算能力来满足当前需求，当业务高峰后，资源能够自动释放，有效节省成本。","categories":[{"name":"架构","slug":"架构","permalink":"http://xiaoningliu.com/categories/架构/"}],"tags":[{"name":"severless","slug":"severless","permalink":"http://xiaoningliu.com/tags/severless/"},{"name":"无服务","slug":"无服务","permalink":"http://xiaoningliu.com/tags/无服务/"},{"name":"无服务架构","slug":"无服务架构","permalink":"http://xiaoningliu.com/tags/无服务架构/"},{"name":"function","slug":"function","permalink":"http://xiaoningliu.com/tags/function/"}]},{"title":"severless 无服务架构简析3 - Serverless架构优劣分析","slug":"severless3","date":"2017-01-07T16:37:01.000Z","updated":"2017-01-07T16:53:04.000Z","comments":true,"path":"2017/01/08/severless3/","link":"","permalink":"http://xiaoningliu.com/2017/01/08/severless3/","excerpt":"","text":"传统的互联网APP主要采用C/S架构，服务器端需长期维持业务进程来处理客户端请求，并调用代码逻辑完成请求响应流程。而在Serverless架构中，应用业务逻辑将基于FAAS架构形成独立为多个相互独立功能组件，并以API服务的形式向外提供服务；同时，不同功能组件间的逻辑组织代码将存储在Amazon Lambda，Azure Function，Google Cloud Functions等产品上，业务代码仅在调用时才激活运行，当响应结束占用资源便会释放。 Serverless与传统云服务的对比广义上讲，云计算的发展实际上就是一个serverless化的过程。近年来涌现的平台即服务（Platform-as-a-Service, PaaS），容器即服务（Container-as-a-Service，CaaS）等，都在一定程度上实现了serverless。每一种服务，都在不同的粒度上对计算进行抽象，而Serverless计算，则将计算的抽象粒度提升到了函数层次，属于函数即服务（Function-as- a-Servcie，FaaS）。相对于PaaS/CaaS，FaaS支持更小的计量和伸缩的粒度，因此在成本和伸缩平滑性上具有独特的优势。 下表从不同维度对比了IaaS，CaaS，PaaS和FaaS。 开发效率 低：用户需要处理机器相关的问题，包括容错，扩容缩容等问题。 中：用户只需要实现业务逻辑。 高：用户只需实现业务逻辑，并通过事件驱动的方式有效组合各项服务。例如上传图片到对象存储服务后，自动触发对应的函数处理。 可伸缩性 低：以机器为粒度，在数分钟内完成扩容/缩容。 中：以容器为粒度，在数秒内完成扩容/缩容。 高：以事件/请求为粒度，扩容/缩容对用户是透明的，随用户访问量自动伸缩。 可运维性 低：用户需要管理操作系统及以上层。 中：用户需要管理容器即以上层。 高：用户需要管理应用及以上层。 成本 高：按照资源规格，小时时间粒度计费。 低：按照资源规格，毫秒时间粒度计费。 Serverless的优点低运营成本在业务突发性极高的场景下，系统为了应对业务高峰，必须构建能够应对峰值需求的系统，这个系统在大部分时间是空闲的，这就导致了严重的资源浪费和成本上升。在微服务架构中，服务需要一直运行，实际上在高负载情况下每个服务都不止一个实例，这样才能完成高可用性；在Serverless架构下，服务将根据用户的调用次数进行计费，按照云计算pay-as-you-go原则，如果没有东西运行，你就不必付款，节省了使用成本。同时，用户能够通过共享网络、硬盘、CPU等计算资源，在业务高峰期通过弹性扩容方式有效的应对业务峰值，在业务波谷期将资源分享给其他用户，有效的节约了成本。 简化设备运维在原有的IT体系中，开发团队即需要维护应用程序，同时还要维护硬件基础设施；Serverless架构中，开发人员面对的将是第三方开发或自定义的API 和URL，底层硬件对于开发人员透明化了，技术团队无需再关注运维工作，能够更加专注于应用系统开发。用户不再需要管理服务器。部署升级简化为上传代码，回滚至指定版本变得快速易用。 提升可维护性Serverless架构中，应用程序将调用多种第三方功能服务，组成最终的应用逻辑。目前，例如登陆鉴权服务，云数据库服务等第三方服务在安全性、可用性、性能方面都进行了大量优化，开发团队直接集成第三方的服务，能够有效的降低开发成本，同时使得应用的运维过程变得更加清晰，有效的提升了应用的可维护性。 开发效率高这一点在现在互联网创业公司得到很好的体现，创业公司往往开始由于人员与资金等问题，不可能每个产品线都同时进行，这时候就可以考虑第三方的Baas平台，比如使用阿里云提供的RDS，极光推送的消息推送，Bmob支付以及地理位置等等，能够很快进行产品开发的速度，把工作重点放在业务实现上，把产品更快的推向市场。 用户不必考虑服务器相关的容错，负载均衡，自动伸缩等方面的问题，开发难度降低。函数计算要求用户将系统解耦为一组功能单一的函数，相互配合完成。因此一些公共的组件，例如身份验证，能够抽象出来，借助专门的服务完成，无需自己实现。函数计算内建日志，性能指标监控等功能，用户不再需要自己配置维护相关系统。 高效平滑伸缩函数执行能力实时横向平滑伸缩，对用户完全透明。很适合访问模式有明显波峰波谷的应用。 Serverless的缺点不适合所有场景Serverless服务在公共云中运行，因此非常关键的任务应用程序不一定可以充分依赖它。比如执行大量交易的银行系统或患者生命支持系统需要比公共云系统能够提供的更高水平的性能和可靠性。有可能组织可以使用专用硬件或运行私有或混合云与自己的计算服务，才可能满足可服务性和可靠性要求。 没有统一的行业标准平台会提供Serverless架构给大玩家，比如AWS Lambda，运行它需要使用AWS指定的服务，比如API网关，DynamoDB，S3等等，一旦你在这些服务上开发一个复杂系统，你会粘牢AWS，以后只好任由他们涨价定价或者下架等操作，个性化需求很难满足，不能进行随意的迁移或者迁移的成本比较大，同时不可避免带来一些损失。Baas行业内一个比较典型的事件，2016年1月19日Facebook关闭曾经花巨额资金收购的Parse，造成用户不得不迁移在这个平台中产生一年多的数据，无疑需要花费比较大的人力和时间成本。 较大的供应商依赖Serverless架构中会对云服务商本身产生极大的依赖，即供应商锁定。如果开发人员决定使用第三方API和服务（包括AWS），那么架构可能会强烈耦合到正在使用的平台。 需要彻底考虑供应商锁定的含义以及使用第三方服务的风险，包括公司可行性，数据主权和隐私，成本，支持，文档和可用功能集。 松耦合架构并不能降低复杂度目前的情况也只适合简单的应用开发，缺乏大型成功案例的推动。对于Serverless缺乏统一的认知以及相应的标准，无法适应所有的云平台。从集中设计方法到更分散的Serverless方法不会自动降低底层系统的复杂性。由于需要进行远程而不是进程内调用，以及需要处理网络中的故障和延迟，解决方案的分布式特性可能会带来自身的挑战。","categories":[{"name":"架构","slug":"架构","permalink":"http://xiaoningliu.com/categories/架构/"}],"tags":[{"name":"severless","slug":"severless","permalink":"http://xiaoningliu.com/tags/severless/"},{"name":"无服务","slug":"无服务","permalink":"http://xiaoningliu.com/tags/无服务/"},{"name":"无服务架构","slug":"无服务架构","permalink":"http://xiaoningliu.com/tags/无服务架构/"},{"name":"function","slug":"function","permalink":"http://xiaoningliu.com/tags/function/"},{"name":"优劣分析","slug":"优劣分析","permalink":"http://xiaoningliu.com/tags/优劣分析/"}]},{"title":"severless 无服务架构简析2 - 架构设计","slug":"severless2","date":"2017-01-07T16:36:01.000Z","updated":"2017-01-07T16:47:24.000Z","comments":true,"path":"2017/01/08/severless2/","link":"","permalink":"http://xiaoningliu.com/2017/01/08/severless2/","excerpt":"","text":"Serverless架构设计原则无服务器架构有五大原则，描述了一个理想的无服务器系统应该如何构建。在构建无服务器架构时，可以运用这些原则，帮助指导你做出决定。 根据需要，使用计算服务来执行代码。 编写单一用途的无状态函数。 设计基于推送的、事件驱动的管道。 创建更粗实、更强大的前端。 拥抱第三方服务。 无服务器架构是SOA概念的自然延伸。在无服务器架构中，所有自定义代码作为孤立的、独立的、常常细粒度的函数来编写和执行，这些函数在AWS Lambda之类的无状态计算服务中运行。开发人员可以编写函数，执行几乎任何常见的任务，比如读取和写入到数据源、调用函数以及执行计算。在比较复杂的情况下，开发人员可以构建更复杂的管道，编排多个函数的调用。可能会有这种场景：仍需要服务器来处理某个任务。然而，这种情况并不多见；作为开发人员，应该尽量避免运行服务器、与之交互。 以下针对五大原则逐一进行解析。 根据需要使用计算服务执行代码无服务器架构是SOA概念的自然延伸。在无服务器架构中，所有自定义代码作为孤立的、独立的、常常细粒度的函数来编写和执行，这些函数在AWS Lambda之类的无状态计算服务中运行。开发人员可以编写函数，执行几乎任何常见的任务，比如读取和写入到数据源、调用函数以及执行计算。在比较复杂的情况下，开发人员可以构建更复杂的管道，编排多个函数的调用。可能会有这种场景：仍需要服务器来处理某个任务。然而，这种情况并不多见；作为开发人员，你应该尽量避免运行服务器、与之交互。 编写单一用途的无状态函数作为软件工程师，在设计函数时应该尽量着眼于单一职责原则（SRP）。单单处理某一项任务的函数更容易测试、运行稳定，而且带来的错误和意外的副作用比较少。通过以一种松散编排的方式将函数和服务组合起来，就能构建照样易于理解、易于管理的复杂后端系统。拥有明确定义的接口的细粒度函数也更有可能在无服务器架构里面被重复使用。 为Lambda等计算服务编写的代码应该以无状态方式来构建。它不得假设：本地资源或进程会在当前的会话之后生存下去。无状态性功能很强大，因为它让平台得以迅速扩展，以处理数量不断变化的入站事件或请求。 设计基于推送的、事件驱动的管道可以构建满足任何用途的无服务器架构。系统可以一开始就构建成无服务器，也可以逐步重新设计现有的整体单一式应用程序，以便充分发挥这种架构的优势。最灵活、最强大的无服务器设计是事件驱动型的。图4显示了我们如何将亚马逊的简单存储服务（S3）、Lambda和Elastic Transcoder连接起来，构建一条事件驱动的、基于推送的管道。 构建事件驱动的、基于推送的系统常常有望降低成本和复杂性（你不需要运行额外代码来轮询变更），可能让整个用户体验更流畅。不言而喻，虽然事件驱动的、基于推送的模式是个美好的目标，但它们并非在所有情况下都是适当的或可以实现的。有时候，你不得不实施一个Lambda函数来轮询事件源或按时间表运行。 在这个例子中，用户上传一段转码成不同格式的视频。上传创建了一个事件，从而触发了Lambda函数。该函数创建一个转码作业。转码作业提交给转码视频服务，新的视频创建后，被保存到另一个S3存储桶。保存新视频这个过程触发了另一个Lambda函数，该函数反过来更新数据库。数据库中一个新的条目触发了最后一个函数，该函数创建通知，并调用通知服务，实现调派。在这个例子中，所有函数和服务仅仅负责一个动作，整个编排易于调整。 创建更粗实、更强大的前端有必要记住这一点，在Lambda中运行的自定义代码应该快速执行。较早终结的函数较便宜，因为Lambda定价基于请求数量、执行时间段以及分配的内存量。在Lambda中要处理的事务比较少来得比较省钱。此外，拥有调用服务的更丰富的前端有利于更好的用户体验。在线资源之间更少的环节和缩短的延迟会让人觉得应用程序的性能和可用性更好。 数字签名的令牌让前端可以与不同的服务（包括数据库）直接进行通信。相比之下，在传统系统中，所有通信经由后端服务器来进行实现。让前端与服务进行通信有助于创建环节少得多、尽快获得所需资源的系统。 然而，不是一切都可以或者都应该在前端执行。有些秘密无法交给客户端设备。处理信用卡或向订户发送电子邮件只能由不受最终用户控制的服务来完成。在这种情况下，就需要计算服务来协调动作、验证数据，并实施安全。 另外要考虑的重要一点是一致性。如果前端负责写入到多个服务，可是中途出现故障，就会导致系统处于不一致的状态。在这种情况下，应该使用Lambda函数，因为它可以旨在从容地处理错误，重新尝试失败的操作。原子性和一致性在Lambda函数中实现起来和控制起来比在前端中容易得多。 拥抱第三方服务如果第三方服务能提供价值、减少自定义代码，自然欢迎它们加入。如今，开发人员可以充分利用许多服务，从用于验证的Auth0服务，到用于支付处理的Stripe或Braintree服务，不一而足。只要考虑到价格、性能和可用性等因素，开发人员就应该试着采用第三方服务。开发人员花时间解决其领域独有的问题要比重复构建别人已经实施的功能有意义得多。如果已有了切实可行的第三方服务和API，别纯粹为了构建而构建。应站在巨人的肩上达到新的高度。 Serverless架构的推荐设计软件设计已从昔日代码在大型机上运行，变成如今在多层系统上运行：在许多设计中，表示层、数据层和应用/逻辑层具有重要地位。在每层里面，可能有多个逻辑层次处理某一功能或领域的特定方面。还有可能跨众多层次的横切组件（cross-cutting component），比如日志或异常处理系统。青睐分层可以理解。分层让开发人员得以将关注点分离开来，开发出更易维护的应用程序。 但是，反过来也可能如此。层次太多可能导致效率低下。一个小小的变化常常带来连锁反应，导致开发人员修改整个系统中的每个层次，把大量的时间和精力花费在实施和测试上。层次数量越多，久而久之系统会变得越复杂、越笨拙。图4显示了具有多个层次的分层架构的一个例子。 无服务器架构实际上有助于解决分层、非得更新太多对象这一问题。开发人员有机会消除或尽量减少层次，只要将系统分成多个功能，让前端得以安全地与服务、甚至数据库直接进行通信，如图5所示。这一切都可以以一种有组织的方式来实现，可以清楚地定义服务边界，防止意大利面条式实施和依赖项恶梦，让Lambda函数成为自治式，并且规划函数和服务如何交互。 无服务器方法解决不了所有问题，也无法消除系统的底层复杂性。然而，如果实施得当，它还是可以为减少、厘清和管理复杂性带来机会。精心规划的无服务器架构可以让开发人员更容易在将来做出变化，这对任何长期的应用程序来说都是一个重要因素。下一节将更详细地讨论服务的组织和编排。 一些开发人员对于层次（layer）与层（tier）之间的区别分不太清楚。层是一种模块边界，它是为了隔离系统的主要组件而存在的。用户看得见的表示层与包括业务逻辑的应用层分开来。反过来，数据层是另一个独立的系统，负责数据的管理、持久化和访问。分组在一个层中的组件可能实际上驻留在不同的基础设施上。层次是逻辑片段，负责执行应用程序中特定的职责。每一层在里面可能有多个层次，负责功能的不同部分，比如域服务。 从现有应用转换到Serverless架构Serverless方法的一个优点是现有应用可以逐渐转换为Serverless架构。如果开发人员面对一个单一的代码库，他们可以逐渐分开，创建应用程序可以与之通信的Lambda函数。 最好的方法是最初创建一个原型来测试，开发人员假设如果系统部分或全部无服务器的情况下系统将如何运行。遗留系统往往具有需要创造性解决方案进行和任何大规模的重构。因此将存在设计与转换中的妥协与过度，系统可能最终是一个混合，参见图6，但是整体系统可能会逐步的将一些方面使用Serverless和使用第三方服务，而不是继续使用传统架构，不再扩展或需要昂贵的基础架构运行。 从传统的基于服务器的应用程序到可扩展的Serverless架构的过渡可能需要时间才能正确完成。它需要仔细和缓慢地进行，开发人员需要有一个良好的测试计划和一个伟大的DevOps战略作为开始。","categories":[{"name":"架构","slug":"架构","permalink":"http://xiaoningliu.com/categories/架构/"}],"tags":[{"name":"severless","slug":"severless","permalink":"http://xiaoningliu.com/tags/severless/"},{"name":"无服务","slug":"无服务","permalink":"http://xiaoningliu.com/tags/无服务/"},{"name":"无服务架构","slug":"无服务架构","permalink":"http://xiaoningliu.com/tags/无服务架构/"},{"name":"function","slug":"function","permalink":"http://xiaoningliu.com/tags/function/"}]},{"title":"severless 无服务架构简析1","slug":"severless","date":"2017-01-07T16:35:01.000Z","updated":"2017-01-07T17:00:29.000Z","comments":true,"path":"2017/01/08/severless/","link":"","permalink":"http://xiaoningliu.com/2017/01/08/severless/","excerpt":"","text":"移动互联网、物联网和大数据应用的快速发展极大地促进了人们对云计算的需求。但是让应用架构拥有良好的可伸缩性和高可用性并非易事，运维和管控庞大的基础架构更是极大的挑战。近年来，一个新的架构风格Serverless成了热门话题。 Serverless架构预示着构建可扩展、强大、具有成本效益和高性能的后端系统的新方法。同时鼓励通过使用Serverless计算服务来执行代码来创建应用程序的新方式。Serverless可以使开发人员专注于真正重要的事务，如解决业务问题和快速迭代。免于业务进行相关的传统成本，例如配置服务器，管理基础设施，修补软件，或支付未使用的计算资源。 本文将全面阐述Serverless架构与传统架构的区别，优势及具体应用场景等。 Serverless简介近些年来，移动和物联网应用极大推动了Serverless架构与技术的迅猛发展。这种新模式基于微服务架构，正在彻底改变软件开发和部署领域。 值得注意的是，Serverless架构并不是真正的没有服务器，使用“无服务器”有点用词不当。无论使用AWS Lambda之类的计算服务来执行代码还是与API进行交互，仍然有服务器在后台运行。区别在于，这些服务器隐藏起来，我们是看不见的。我们不需要考虑基础设施，也无法调整/改动底层操作系统。别人负责基础设施管理的基本细节，那样我们可以腾出时间处理其他事情。无服务器技术是指，在计算服务中运行代码，并与服务和API进行交互，以完成任务。 Serverless框架被外部事件触发后，会调用自主的代码片段。这些代码片段彼此松散耦合，各个片段实际上旨在每次执行一个任务。Serverless框架负责在运行时编排代码片段。它就好比是在云端可扩展、对开发人员友好的IFTTT服务。这种新兴的云计算服务交付模式为开发人员和管理员带来了许多优点。它提供了合适的灵活性和控制性级别，因而在IaaS和PaaS之间找到了一条中间道路。 Serverless的发展在一个典型的Web应用程序中，服务器接受来自前端的HTTP请求，处理请求。数据在保存到数据库之前可能经过无数个应用层次。最后，后端生成响应――可能采用JSON或完全呈现的标记这种形式，响应被发回给客户端（图1）。当然，一旦将其他元素考虑进来，比如负载均衡、事务、集群、缓存、消息传递和数据冗余，大多数系统比较复杂。大多数这种软件需要服务器在数据中心或在云端运行，这些服务器需要加以管理、维护、打补丁和备份起来。 服务器的配置、管理和打补丁是一项很耗费时间的任务，常常需要专门的操作人员。很难搭建并高效地运行一个重大的环境。基础设施和硬件是任何IT系统的必要组成部分，但它们也常常让人容易分心，忽视最重要的事情：解决业务问题。 过去这几年出现了平台即服务（PaaS）和容器等技术，这些解决方案有望解决这个头痛的问题：基础设施环境不一致、冲突和服务器管理开销。PaaS是一种云计算，它为用户提供了运行软件的平台，同时把一部分底层基础设施隐藏起来。为了有效地使用PaaS，开发人员需要编写针对该平台相应功能特性的软件。由于大多数PaaS实现方法具有短暂性，把当初被设计成在独立服务器上运行的老式应用程序迁移到PaaS服务，需要额外的开发工作。不过，如果面临选择，许多开发人员会决定使用PaaS，而不是更传统、更手动化的解决方案，那是由于PaaS减少了维护和平台支持方面的要求，这可以理解。 容器化是一种隔离应用程序的方法，让应用程序有自己的环境。这种轻量级方法可替代全面的虚拟化。容器是孤立的、轻量级的，但它们需要部署到服务器上，无论在公共云上、在私有云中还是在现场。如果依赖关系明确，容器是一种出色的解决方案，不过它们在内务处理（housekeeping）方面有各自的挑战和复杂性。它们并不是与仅仅能够直接在云端运行代码来得一样容易。 当我们还在容器的浪潮中前行时，已经有一些革命先驱悄然布局另外一个云计算战场：Serverless。2014年11月14日，亚马逊AWS发布了新产品Lambda。当时Lambda被描述为：一种计算服务，根据时间运行用户的代码，无需关心底层的计算资源。从某种意义上来说，Lambda姗姗来迟，它更像S3，更像云计算的PaaS理念：客户只管业务，无需担心存储和计算资源。 而在此之前不久，2014年10月22日，谷歌今天收购了实时后端数据库创业公司Firebase。Firebase声称开发者只需引用一个API库文件就可以使用标准REST API的各种接口对数据进行读写操作，只需编写 HTML＋CSS＋JavaScrip前端代码，不需要服务器端代码（如需整合，也极其简单）。相对于上两者，Facebook 在2014年二月收购的 Parse，则侧重于提供一个通用的后台服务。不过这些服务被称为Serverless或no sever。很像PASS，用户不需要关心基础设施，只需要关心业务，这是迟到的PaaS，也是更实用的PaaS。这很有可能将会变革整个开发过程和传统的应用生命周期，一旦开发者们习惯了这种全自动的云上资源的创建和分配，或许就再也回不到那些需要微应用配置资源的时代里去了。 Lambda是亚马逊网络服务（AWS）提供的一种计算服务。Lambda能够以一种大规模并行方式执行代码，以响应事件。Lambda拿来你的代码后即可运行，根本不需要配置服务器、安装软件、部署容器，或者是为低层细节而操心。AWS负责配置和管理运行实际代码的弹性计算云（EC2）服务器，并提供开发人员不需要考虑的一套高可用性计算基础设施，包括容量配置和自动扩展机制。无服务器架构这个词是指这些新型的软件架构：不需要直接访问服务器就能运行。通过采用Lambda，并充分利用各种功能强大的单一用途的API和Web服务，开发人员就可以迅速构建松散耦合、可扩展、高效的架构。无服务器架构的最终目的就是，远离服务器和基础设施方面的问题，让开发人员可以主要专注于代码。 Lambda是一种计算服务，它在AWS基础设施上执行用用JavaScript（node.js）、Python或Java编写的代码。源代码部署到孤立的容器上，该容器有单独分配的内存、磁盘空间和处理器。代码、配置和依赖项这一组合通常被称为Lambda函数。Lambda运行时环境可以并行多次调用某个函数。Lambda支持推拉事件操作模式，并与数量众多的AWS服务整合起来。函数可以通过API网关由HTTP请求来调用，也可以按时间表来运行。请注意：Lambda并不是市面上唯一的计算服务。微软Azure函数（Microsoft Azure Functions）、IBM Bluemix OpenWhisk和谷歌云函数（Google Cloud Functions）是可能应该关注的其他计算服务。、 Serverless的概念Serverless是一种基于互联网的技术架构理念，应用逻辑并非全部在服务端实现，而是采用FAAS（Function as a Service）架构，通过功能组合来实现应用程序逻辑。同时，Serverless架构能够让开发者在构建应用的过程中无需关注计算资源的获取和运维，由平台来按需分配计算资源并保证应用执行的SLA，按照调用次数进行计费，有效的节省应用成本。 提到Serverless，大家都想到一张经典图描述传统的互联应用架构图与Serverless architactures的不同点，Serverless架构能够让开发者在构建应用的过程中无需关注计算资源的获取和运维，由平台来按需分配计算资源并保证应用执行的SLA，按照调用次数进行计费，有效的节省应用成本。 Serverless是最新兴起的架构模式，中文意思是“无服务器”架构。目前，业界并没有给出明确的定义，把其分成两种类型，分别为“Backend as a Service” 和 “Functions as a Service”。“Backend as a Service”即BaaS，是一种新型的云服务，旨在为移动和Web应用提供后端云服务，实现对逻辑和状态进行管理，包括云端数据/文件存储（例如Parse、Firebase）、消息推送、应用数据分析等等。可以说BaaS是诞生于移动互联网，为了加速移动应用开发和降低成本而形成的开发架构。BaaS可以带来后端能力的服务化，服务化也为后端能力优化管理带来了可能，这些能力通过服务开发者而诞生，重复的建设和规划会在初期就得到避免。 开发者通过使用这些服务，实现自己的业务功能的同时，也会对服务的能力进一步提出要求，促进后端服务的发展。BaaS是在PaaS和SaaS之间，为了满足移动互联网快速发展的需要，将后端的能力以服务形式提供，是在PaaS平台开发能力的基础上，用SaaS的思路，将后端能力服务化，让开发者在此基础上开发自己的Software解决方案。 “Functions as a Service”即FaaS，指这样的应用，一部分服务逻辑由应用实现，但是跟传统架构不同在于，他们运行于无状态的容器中，可以由事件触发，短暂的，完全被第三方管理，功能上FaaS就是不需要关心后台服务器或者应用服务，只需关心自己的代码即可。其中AWS Lambda是目前最佳的FaaS实现之一。 Serverless代表无服务器计算技术崛起， 是微服务的一种表现形式，是新一代云服务和开发架构的实践，是云计算发展重点方向之一。Serverless架构是BaaS实现的精髓，是BaaS进一步的解读，FaaS（Function as a service）是BaaS中云代码的实现方式。作为使用方我们不仅熟悉业内Serverless架构的经典产品，而且需要进行学习进而开发属于自己Serverless产品，或者能够很好的进行选型为自己产品快速的开发与运营提供基础条件。 在许多不同的系统和应用程序架构当中，面向服务的架构（SOA）在软件开发人员当中具有很高的知名度。这种架构清楚地使这个想法概念化：系统可以由许多独立的服务组成。SOA方面的文章已写了不少，可是由于开发人员常常把设计理念与具体的实施和属性混为一谈，所以它仍存在争议和误解。 SOA没有硬性规定使用任何特定的技术。相反，它鼓励这样一种架构方法：开发人员创建自治服务，这些服务通过消息传递来进行联系，常常有一种模式（schema）或契约（contract），定义了消息是如何创建或交换的。服务的可重用性、自主性、可组合性、细粒度和可发现性，这些都是与SOA有关的重要原则。 微服务和无服务器架构在核心思想上与面向服务的架构一脉相承。它们保留了许多上述原则和理念，同时试图消除老式的面向服务架构具有的复杂性。 最近出现的一股趋势是，使用微服务架构来实施系统。开发人员往往把微服务考虑成小型、单独、完全独立的服务，它们围绕一个特定的业务用途或功能而建。微服务可能有一个应用程序层，有自己的API和数据库。 理想情况下，微服务应该易于替换，每个服务用一种适当的框架和语言编写而成。微服务可以用不同的通用语言或特定领域语言（DSL）来编写，光这一点就让许多开发人员为之着迷。虽然可以通过使用合适的语言或针对相应任务的一套专用库来获得一些好处，但这也常常是个陷阱。如果拥有多种语言和框架，支持起来有难度；要是没有一套严格的准则，会在将来导致混淆和困难。 每个微服务可能保持其状态、存储数据，这增加了系统的复杂性。一致性和协调性管理也可能成为一个问题，因为状态必须常常跨不同的服务来加以同步。微服务可以通过消息总线间接联系，也可以通过将消息发给对方来直接联系。 可以说，无服务器架构同样体现了来自微服务的许多原则。毕竟，每个计算函数都可以被认为是其自己的独立服务，这取决于你如何设计系统。然而，你不需要完全接受微服务口号，就可以围绕某个特定的业务用途来开发每个函数或服务，保持状态，等等。 无服务器架构的好处在于，你想运用几个微服务原则，就可以随意运用几个，非常的方便快捷。","categories":[{"name":"架构","slug":"架构","permalink":"http://xiaoningliu.com/categories/架构/"}],"tags":[{"name":"severless","slug":"severless","permalink":"http://xiaoningliu.com/tags/severless/"},{"name":"无服务","slug":"无服务","permalink":"http://xiaoningliu.com/tags/无服务/"},{"name":"无服务架构","slug":"无服务架构","permalink":"http://xiaoningliu.com/tags/无服务架构/"},{"name":"function","slug":"function","permalink":"http://xiaoningliu.com/tags/function/"}]},{"title":"Shadowsocks on Ubuntu 16","slug":"shadowsocks","date":"2017-01-06T11:38:00.000Z","updated":"2017-01-06T15:16:55.000Z","comments":true,"path":"2017/01/06/shadowsocks/","link":"","permalink":"http://xiaoningliu.com/2017/01/06/shadowsocks/","excerpt":"","text":"导读：Shadowsocks 是一种简便快捷的代理工具，其优异的性能可以在配置很低的机器中流畅运行，因此受到广泛的欢迎。以下是在一台全新的 Ubuntu Server 中使用 apt-get 安装并搭建 Shadowsocks Server 的过程。 本文将涉及如下的要点： apt-get 的使用 shadowsocks config 配置文件的配置 shadowsocks 服务的启动 安装与配置步骤步骤一 使用 apt-get 安装 Shadowsocks Server12sudo apt updatesudo apt install shadowsocks 步骤二 创建配置文件配置文件包含了 Shadowsocks 服务所需要的简便配置，比如加密方式与密码设置等。值得注意的是，Shadowsocks 可以不需要配置文件运行，在没有配置文件的情况下，密码等信息需要作为配置参数的形式在启动服务时传递。 为方便重复利用配置文件，可以建立配置文件，并将配置文件放置在当前用户目录下面。 12cd ~vim ss.config 在创建的 ss.config 的文件中，加入如下内容，内容以 json 格式存储，注意最后一行没有逗号。 123456789&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:4433, &quot;local_port&quot;:4433, &quot;password&quot;:&quot;123123123&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;auth&quot;: true&#125; 步骤三 启动服务使用 apt-get 安装好 Shadowsocks Server 之后，可以直接使用 ssserver 命令启动服务。 1ssserver -c ~/ss.config -d start 命令中的参数 -c 指的是配置文件的路径，这里指向了当前用户目录(~)下的 ss.config 文件。参数 -d 指的是使用 daemon 的方式启动，即可以在后台运行 Shadowsocks 服务。 步骤四 设置自启动按上面的步骤配置好之后，如果遇到服务器的重新启动，那么我们需要手工登录到服务器重新运行上面的命令。我们可以将上面的命令配置到系统启动的脚本中免除手工操作的繁琐步骤。 首先，定位 ssserver 的绝对路径，可以通过 locate 命令实现。 12myss@myss:~$ locate ssserver/usr/local/bin/ssserver 另外，定位 rc.local 脚本文件的位置，可以在其中加入系统启动时候的脚本命令。 12myss@myss:~$ locate rc.local/etc/rc.local 打开 rc.local 在其中加入自动启动 Shadowsocks ssserver 服务的命令。 1sudo vim /etc/rc.local 在 exit 0 行之前，加入如下命令，保存退出。 1/usr/local/bin/ssserver -c /home/myss/ss.config -d start 问题调试如果配置好之后不能正常连接应该怎么查找故障？这里介绍 linux 中常见的命令来辅助定位故障。 确认端口已经监听上述 ss.config 配置文件中，我们使用了 4433 端口作为监听端口，因此我们使用网络调试命令查看端口是否正常打开。 1netstat -tpn netstat 命令可以查看当前系统网络连接的状况，其中四个参数的含义如下： -t 代表查找 TCP 的通信连接，因为 Shadowsocks 的服务是基于 TCP 协议。 参数 -p 代表显示对应端口占用的程序。 参数 -n 代表以数字的形式显示端口号码，这里我们需要寻找 4433 端口是否存在。 123456myss@myss:~$ netstat -tnp(No info could be read for &quot;-p&quot;: geteuid()=1000 but you should be root.)Active Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name TIME_WAIT - tcp 0 460 10.0.0.4:22 183.195.251.236:56598 ESTABLISHED - tcp 0 0 10.0.0.4:4433 58.196.146.219:59475 TIME_WAIT - 如上所示，4433端口已经处于 TCP 的等待状态，说明端口已经正常打开，端口没有问题。如果没有寻找到 4433 端口，那么说明 ssserver 的服务没有正常启动。可以按照下述方法，动态的查看 ssserver 的日志。 使用交互式方式查看日志我们去掉 -d 参数，直接启动 ssserver，这样可以查看启动时候的日志，根据提示的错误信息，我们可以针对性的解决问题。 1ssserver -c ~/ss.config 2017-01-06","categories":[{"name":"工具","slug":"工具","permalink":"http://xiaoningliu.com/categories/工具/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://xiaoningliu.com/tags/shadowsocks/"},{"name":"科学上网","slug":"科学上网","permalink":"http://xiaoningliu.com/tags/科学上网/"},{"name":"工具","slug":"工具","permalink":"http://xiaoningliu.com/tags/工具/"},{"name":"翻墙","slug":"翻墙","permalink":"http://xiaoningliu.com/tags/翻墙/"},{"name":"Great File Wall","slug":"Great-File-Wall","permalink":"http://xiaoningliu.com/tags/Great-File-Wall/"},{"name":"GFW","slug":"GFW","permalink":"http://xiaoningliu.com/tags/GFW/"},{"name":"网络","slug":"网络","permalink":"http://xiaoningliu.com/tags/网络/"},{"name":"自启动","slug":"自启动","permalink":"http://xiaoningliu.com/tags/自启动/"}]},{"title":"常见算法","slug":"常见算法","date":"2016-03-27T13:45:39.000Z","updated":"2016-04-01T14:13:05.000Z","comments":true,"path":"2016/03/27/常见算法/","link":"","permalink":"http://xiaoningliu.com/2016/03/27/常见算法/","excerpt":"","text":"常见算法 常见算法，持续整理中 数字的运算最大公约数1234int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125; 辗转相除法，以上算法要求a与b都是正整数，不要求a与b的大小关系。 数字的约数个数123456789101112131415161718192021222324252627282930313233343536373839long divisors(long a)&#123; if (a == 1) return 1; else if (a &lt; 1) return 0; // 求得质因子 unordered_map&lt;long, long&gt; primeSubNums; long ini = 2; while(a&gt;1) &#123; for(long i= ini; i&lt;=a; i++) &#123; if(a%i == 0) &#123; a = a/i; primeSubNums[i]++; ini = i; break; &#125; &#125; &#125; // 判断是否为质数，如果是合数则使用质因子求得约数个数 if (primeSubNums.size() == 1 &amp;&amp; primeSubNums[a] &gt; 0) &#123; return primeSubNums.size() + 1; &#125; else &#123; long res = 1; for (auto i : primeSubNums) &#123; res *= (i.second + 1); &#125; return res; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://xiaoningliu.com/categories/算法/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://xiaoningliu.com/tags/面试/"},{"name":"备忘","slug":"备忘","permalink":"http://xiaoningliu.com/tags/备忘/"},{"name":"算法","slug":"算法","permalink":"http://xiaoningliu.com/tags/算法/"}]},{"title":"网络基本知识","slug":"网络基本","date":"2016-03-25T04:05:21.000Z","updated":"2016-03-25T14:51:49.000Z","comments":true,"path":"2016/03/25/网络基本/","link":"","permalink":"http://xiaoningliu.com/2016/03/25/网络基本/","excerpt":"","text":"网络基本知识 网络通信的五层划分 应用层 传输层 TCP、UDP 网络层 路由器、IP地址、ARP、ICMP、RARP数据包Package 链路层 交换机、帧Frame 物理层 网线 TCP和UDP的区别 TCP可靠传输，无丢包重复等 TCP保证顺序 TCP耗费资源较多，重量级 TCP是面向连接的（逻辑上的连接而已，短暂重拔网线也无问题），而UDP不是 TCP的基础知识TCP的三次握手如图所示，三次握手。主要是要初始化Sequence Number 的初始值。 为什么要三次握手为了防止两次握手中已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 TCP的SYN洪泛Client发出sync请求后便丢弃，服务器进入一直重发ack阶段，从而浪费服务器资源。 第三次握手ACK失败咋办因此，TCP后面提出新的机制，可以失败时服务器并不会重传ACK报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是为了防止SYN洪泛攻击。原文链接 TCP如何保证顺序依靠seq和ack双方的sequence number TCP有几个阶段三个，connect、传输、close阶段 accept()发生在哪个阶段发生在传输阶段，即三次握手完成之后 TCP的四次断开握手TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。换言之，通信的一端可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。TCP连接的这种状态称为半关闭（half close）状态。 当客户端向服务器发送一个FIN报文段后，此连接被半关闭了。服务器发送ACK报文段来接受这个半关闭。但是服务器仍然可以发送数据，当服务器把处理完的数据都发送完毕之后，发送FIN报文段（半关闭），并且被客户发来的ACK予以确认（关闭）。 最后，TCP协议是一项很复杂的协议，很难充分的掌握，但一些皮毛和可靠性方面的基础是需要知道的。 最后的ACK失败咋办Server会重发FIN，直到超时Close。相关链接 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？建立连接这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。 关闭连接但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 其他ARP把连在同一个网上计算机的IP地址转换为该机的物理地址 ### 相关资料 果壳TCP资料 简书TCP资料","categories":[{"name":"网络","slug":"网络","permalink":"http://xiaoningliu.com/categories/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://xiaoningliu.com/tags/网络/"},{"name":"TCP","slug":"TCP","permalink":"http://xiaoningliu.com/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"http://xiaoningliu.com/tags/UDP/"}]},{"title":"C++基础","slug":"CPP基础","date":"2016-03-25T02:56:58.000Z","updated":"2016-04-01T14:51:15.000Z","comments":true,"path":"2016/03/25/CPP基础/","link":"","permalink":"http://xiaoningliu.com/2016/03/25/CPP基础/","excerpt":"","text":"C++类相关要点 指针常量和常量指针C++中“指针常量”和“常量指针”这两个概念往往很令人困惑，有时候一时理解下来，过一段时间也会忘记。但抛去概念名字，只看代码，却可以发现有明显的规律。 123456int *p; // int指针int * const p; // int指针常量，指针指向的地址为常量const int *p; // int常量指针，指针指向的int变量为常量int const *p; // int常量指针，指针指向的int变量为常量const int * const p; // 两者均是int const * const p; // 两者均是 其实只需要记住，星号之后的const修饰的是指针本身，星号之前的const修饰的是指向的类型。 而对于“常量指针”和“指针常量”的概念名来说，可以采用从右至左读的方式，即： “常量指针”是指向常量的指针，const在*前面 “指针常量”是指指针本身是常量，*在const前面 const的具体实现C++ 只规定了编译器的行为：C++ 要求编译器拒绝所有直接修改 const 对象的情况，所以具体实现是和编译器相关的。 C和C++中const的具体实现是和编译器相关的 一般进行的是在编译期间的检查，检查有无试图修改const的变量 有的编译器可能将const int i = 10中的i在代码中替换为10 有的编译器会将const变量编译在read-only的内存中 new 和 malloc() 的区别两者都是进行动态内存分配的函数，具体有以下区别： new是操作符而malloc()是标准库函数 两者在C++都可使用，而C只能使用malloc()（所以在C++中没有被淘汰） new与delete对应，malloc()和free()对应 new自动返回带有类型的指针，malloc()需要强制转换返回指针的类型 new会自动计算分配内存大小，而malloc()需要人工计算，如sizeof(int) * 20 new和delete在动态创建或销毁C++类对象的时候，可以自动调用类的构造函数和析构函数（所以在C++中对类使用new和delete） sizeof1234cout&lt;&lt;sizeof(short)&lt;&lt;endl;cout&lt;&lt;sizeof(int)&lt;&lt;endl;cout&lt;&lt;sizeof(long)&lt;&lt;endl;cout&lt;&lt;sizeof(long long)&lt;&lt;endl; 在64位mac系统测试得到： 32位下：2 4 4 8 64位下：2 4 8 8 只有long发生变化，long的长度与指针的长度相同，都为当前位数地址总线长度 指针和引用引用和指针的不同： 没有“空引用”，引用必须初始化 引用初始化之后不可指向其他的变量 vector等模板类中不可存储引用 引用的实现根据编译器的不同而不同，有的是通过指针常量实现的","categories":[{"name":"C++","slug":"C","permalink":"http://xiaoningliu.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://xiaoningliu.com/tags/C/"},{"name":"面试","slug":"面试","permalink":"http://xiaoningliu.com/tags/面试/"}]},{"title":"C++标准库小记","slug":"CPP标准库","date":"2016-03-23T02:11:17.000Z","updated":"2016-03-23T02:15:54.000Z","comments":true,"path":"2016/03/23/CPP标准库/","link":"","permalink":"http://xiaoningliu.com/2016/03/23/CPP标准库/","excerpt":"","text":"C++类相关要点 set和unordered_Set1234567set&lt;int&gt; s1 = &#123;1,2,3,4,5&#125;;if (s1.find(3) != s1.end()) cout&lt;&lt;\"Found it\"&lt;&lt;endl; unordered_set&lt;int&gt; s2 = &#123;1,2,3,4,5&#125;;if (s2.find(3) != s2.end()) cout&lt;&lt;\"Found it\"&lt;&lt;endl; set.find() 的时间复杂度是O(nlog(n))，采用红黑树实现 unordered_set.find() 的时间复杂度通常是常数，采用哈希实现，当哈希结果不好时会退化到线性","categories":[{"name":"C++","slug":"C","permalink":"http://xiaoningliu.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://xiaoningliu.com/tags/C/"},{"name":"标准库","slug":"标准库","permalink":"http://xiaoningliu.com/tags/标准库/"},{"name":"复杂度","slug":"复杂度","permalink":"http://xiaoningliu.com/tags/复杂度/"}]},{"title":"C++类相关要点","slug":"CPP类","date":"2016-03-21T04:45:12.000Z","updated":"2016-04-01T12:08:48.000Z","comments":true,"path":"2016/03/21/CPP类/","link":"","permalink":"http://xiaoningliu.com/2016/03/21/CPP类/","excerpt":"","text":"C++类相关要点 空间12345678910111213class a&#123;&#125;;class b&#123;&#125;;class c:public a&#123; virtual void fun()=0;&#125;;class d:public b,public c&#123;&#125;;// g++ class.cpp -m32cout&lt;&lt;\"sizeof(a)\"&lt;&lt;sizeof(a)&lt;&lt;endl; // 1bytecout&lt;&lt;\"sizeof(b)\"&lt;&lt;sizeof(b)&lt;&lt;endl; // 1bytecout&lt;&lt;\"sizeof(c)\"&lt;&lt;sizeof(c)&lt;&lt;endl; // 包含虚函数指针4bytescout&lt;&lt;\"sizeof(d)\"&lt;&lt;sizeof(d)&lt;&lt;endl; // 包含c的虚函数指针4bytes 使用32bit编译，结果如下： 1234sizeof(a)1sizeof(b)1sizeof(c)4sizeof(d)4 使用64bit编译，结果如下： 1234sizeof(a)1sizeof(b)1sizeof(c)8sizeof(d)8 注意：C++中指针本身的长度、long变量的长度是和内存地址位宽一致的 构造函数1234567891011121314151617181920212223242526class Tran&#123;public: string val; Tran(const string &amp; str): val(str) &#123; cout&lt;&lt;\"隐式转换函数调用\"&lt;&lt;endl; &#125; // 构造函数，实现了隐式转换功能 Tran(const Tran &amp; tr): val(tr.val) &#123; cout&lt;&lt;\"赋值构造函数调用\"&lt;&lt;endl; &#125; // 赋值构造函数 const Tran &amp; operator= (const Tran &amp; tr) &#123; cout&lt;&lt;\"复制函数调用\"&lt;&lt;endl; val = tr.val; return *this; &#125;&#125;;// Tran tran = \"hello\"; // 错误：字符串常量不是string类型的，无法调用隐式转换函数// Tran tran; // 错误：在定义了其他构造函数之后，编译器不会生成默认无参数的构造函数Tran tran2 = string(\"hello\"); // 调用了Tran的第一个构造函数，第一个是隐式转换构造函数Tran tran3 = tran2; // 调用了Tran的第二个构造函数，第二个是赋值构造函数tran3 = tran2; // 调用了Tran的第三个冲在函数，第三个是复制重载函数cout&lt;&lt;tran2.val&lt;&lt;endl; 输出如下： 1234隐式转换函数调用赋值构造函数调用复制函数调用hello","categories":[{"name":"C++","slug":"C","permalink":"http://xiaoningliu.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://xiaoningliu.com/tags/C/"},{"name":"面试","slug":"面试","permalink":"http://xiaoningliu.com/tags/面试/"},{"name":"类","slug":"类","permalink":"http://xiaoningliu.com/tags/类/"},{"name":"重载函数","slug":"重载函数","permalink":"http://xiaoningliu.com/tags/重载函数/"},{"name":"构造函数","slug":"构造函数","permalink":"http://xiaoningliu.com/tags/构造函数/"},{"name":"虚函数","slug":"虚函数","permalink":"http://xiaoningliu.com/tags/虚函数/"}]},{"title":"树的相关算法以及树转换为二叉树","slug":"树转换为二叉树","date":"2016-03-17T01:36:36.000Z","updated":"2016-04-03T09:30:03.000Z","comments":true,"path":"2016/03/17/树转换为二叉树/","link":"","permalink":"http://xiaoningliu.com/2016/03/17/树转换为二叉树/","excerpt":"","text":"树的相关算法以及树转换为二叉树 树的相关概念二叉树 Binary Tree 每个节点可有左右区分的两个子节点(子树)；节点的值可能相同(代码中不能根据值判断是否为同一个节点)； 完全二叉树 二叉树的基础上，树的每一行都是满的(2^(k-1)个节点在第k行)，除了最后一行。最后一行的节点从左到右是满的。 满二叉树 二叉树的基础上，树的每一行都是满的(2^(k-1)个节点在第k行)。 二叉排序树 Binary Search Tree (BST) 在二叉树的基础上，本节点的值必定大于左子树，小于右子树；所有节点的值都不相同； 问题：如何判断一棵树是BST？ 每个节点至多有两个子节点； 每个节点的值必须大于/小于父节点，同时大于/小于父父节点 平衡二叉树 Balanced Binary Tree 或 AVL树 在二叉排序树的基础上，每个节点左右两个子树的高度差不超过1。 保证插入、删除以及查找节点的时间最好和最坏都在log(n) 避免BST树可能退化为链表的可能 带来的代价是维持平衡需要的额外旋转log(n)时间 可以为空树 前缀树 Prefix Tree 或者 Trie Tree 根节点为空，每个字母是一个节点（如26个小写字母），每个节点的子节点同样是。从头到尾会组成一个单词。一棵排序树。 具有的特性： 快速判断某个单词是否存在于一堆单词中；O(LengthofWord) 获得以某个前缀开始的单词的数量； 占用内存较大（每个节点要保存26个指针）； 每个节点包含以下元素 当前字符； 以当前字符结尾的单词个数； 以当前字符为前缀的单词个数； 指向子节点的指针数组； 与Hash的异同： 前缀树较常应用于普通长度的单词（单词长度），对于MD5等较长的无规则字符不太好； Hash在工业中更为常用方便，处理大量数据； 区间树 Segment Tree 属于二叉搜索树，每个节点代表一段范围。用于快速求解随机范围内值的和。更新具体节点的值的花费是O(logn)。 区间树 红黑树与AVL树STL中set、map、multiset、multimap是由红黑树实现的，所以查找速度是O(log(n)) STL中unordered_set、unordered_map、unordered_multiset、unordered_multimap是由hash实现的，所以查找速度是O(1) 相同点 两者均为（自）平衡二叉树的实现算法 插入、删除、查找的算法复杂度相同（红黑树），都是O(log(n)) 不同点 AVL树严格维持左右子树高度差在1之内（严格平衡树），而红黑树并不严格遵守（相对便宜的解决方案） 红黑树插入和删除效率较高（统计性能比AVL好） 红黑树的检索效率不如AVL树 红黑树的根节点是黑的 红黑树或者AVL树与哈希的选取红黑树相对于哈希表，在选择使用的时候有什么依据？ 权衡三个因素: 查找速度, 数据量, 内存使用，可扩展性。 查找速度：哈希更优 数据量与内存：哈希消耗更大 可扩展性：哈希更不易扩展，适应于静态数据 参考资料： 搞定面试中的红黑树问题 红黑树和AVL树的比较 红黑树 VS AVL树 平衡二叉树（解惑 B树 多路树 树转换为二叉树很简单，每个节点的最左边的儿子还是儿子，其他儿子变成这个儿子的孙子、曾孙子等，可以递归进行： 12345678910111213141516171819202122232425struct Node&#123; int val; int childrenNum; Node** children; void addChild(Node* n) &#123; children[childrenNum++] = n; &#125;&#125;;void transfer(Node* root)&#123; if (root == NULL) return; for (int i = 0; i &lt; root-&gt;childrenNum; i++) &#123; transfer(root-&gt;children[i]); // 注意：必须先执行子节点的变换 if (i != 0) root-&gt;children[i - 1]-&gt;addChild(root-&gt;children[i]); &#125; root-&gt;childrenNum = root-&gt;childrenNum == 0 ? 0 : 1;&#125; 树的其他常见算法最低公共祖先节点 Lowest Common Ancesters (LCA)排序二叉树在二叉排序树中，如果两个节点的某个公共父节点的值在两个节点值之间，那么这个节点必然是两个节点的最低公共祖先。 也就是说，在两个节点的所有公共祖先节点中，只有最低公共祖先节点的值在两者之间。 利用这个结论，可以快速的在BST(Binary Search Tree)中找到两个节点值p与q的LCA(p &lt; q)。 12345678910111213141516while (node)&#123; if (p &lt; node-&gt;val &amp;&amp; q &lt; node-&gt;val) &#123; node = node-&gt;left; continue; &#125; if (p &gt; node-&gt;val &amp;&amp; q &gt; node-&gt;val) &#123; node = node-&gt;right; continue; &#125; if (p &lt; node-&gt;val &amp;&amp; q &gt; node-&gt;val) return node; // 找到LCA&#125; 普通二叉树首先，在普通二叉树中没有二叉搜索树的规律，因此可以使用递归进行运算。 通常情况下我们会构造递归函数，目的是返回子树中p与q的LCA，否则返回NULL。 但问题来了，如果节点左右子节点都为NULL，如何判断当前节点是否是p与q的LCA？ 所以可以让递归函数返回子树中是否包含p与q，那么就可以判断出当前节点是否是LCA了。 12345678910111213141516171819202122232425262728293031TreeNode* lowestCommonAncestorHelper(TreeNode* root, TreeNode* p, TreeNode* q, bool &amp; cp, bool &amp; cq) &#123; if (root == NULL) &#123; cp = false; cq = false; return NULL; &#125; bool lcp(false), lcq(false), rcp(false), rcq(false); TreeNode* ln = lowestCommonAncestorHelper(root-&gt;left, p, q, lcp, lcq); if (lcp &amp;&amp; lcq) &#123; cp = true; cq = true; return ln; &#125; TreeNode* rn = lowestCommonAncestorHelper(root-&gt;right, p, q, rcp, rcq); if (rcp &amp;&amp; rcq) &#123; cp = true; cq = true; return rn; &#125; cp = lcp || rcp || (root == p); // 注意：！普通的二叉树可能不是二叉搜索树(BST)，所以树节点的值可能重复 cq = lcq || rcq || (root == q); if ( cp &amp;&amp; cq ) return root; return NULL;&#125; 树的左右对称交换使用递归，左右交换即可。 123456789void reverse(Node * root)&#123; if (root == NULL) return; swap(root-&gt;left, root-&gt;right); // swap和下面reverse的顺序可以调换 reverse(root-&gt;left); reverse(root-&gt;right);&#125; 类似题目对称交换二进制 使用二分法左右交换。 12345678void inverseBinary(int &amp;bin)&#123; bin = ((0x0000FFFF &amp; bin) &lt;&lt; 16) | ( (0xFFFF0000 &amp; bin) &gt;&gt; 16); bin = ((0x00FF00FF &amp; bin) &lt;&lt; 8 ) | ( (0xFF00FF00 &amp; bin) &gt;&gt; 8); bin = ((0x0F0F0F0F &amp; bin) &lt;&lt; 4 ) | ( (0xF0F0F0F0 &amp; bin) &gt;&gt; 4); bin = ((0x33333333 &amp; bin) &lt;&lt; 2 ) | ( (0xCCCCCCCC &amp; bin) &gt;&gt; 2); bin = ((0x55555555 &amp; bin) &lt;&lt; 1 ) | ( (0xAAAAAAAA &amp; bin) &gt;&gt; 1);&#125; 对称交换字符串 使用左右两个指针中间移动交换即可。 深度优先搜索(DFS)与广度优先搜索(BFS)深度优先搜索使用Stack递归即可，而广度优先搜索需要使用队列(deque). 参考资料 WIKI二元搜尋樹","categories":[{"name":"算法","slug":"算法","permalink":"http://xiaoningliu.com/categories/算法/"}],"tags":[{"name":"复杂度","slug":"复杂度","permalink":"http://xiaoningliu.com/tags/复杂度/"},{"name":"面试","slug":"面试","permalink":"http://xiaoningliu.com/tags/面试/"},{"name":"算法","slug":"算法","permalink":"http://xiaoningliu.com/tags/算法/"},{"name":"二叉树","slug":"二叉树","permalink":"http://xiaoningliu.com/tags/二叉树/"},{"name":"树","slug":"树","permalink":"http://xiaoningliu.com/tags/树/"}]},{"title":"常见算法复杂度","slug":"常见算法复杂度","date":"2016-03-16T03:47:46.000Z","updated":"2016-03-16T10:44:46.000Z","comments":true,"path":"2016/03/16/常见算法复杂度/","link":"","permalink":"http://xiaoningliu.com/2016/03/16/常见算法复杂度/","excerpt":"","text":"常见算法复杂度 常见算法复杂度，持续整理中 深度优先搜索(DFS)与广度优先搜索(BFS)这两个算法可以用于图也可以用于树，用于树的情况往往会简单。 使用邻接矩阵存储图: O(n^2) 一共n个点，每个点都要访问一遍，每个点都要读取邻接矩阵获得子节点，需要n次，因此是n*n。 使用邻接表存储图：O(|n| + |e|) 注意：在树中，e = n - 1，因为只有根节点没有上面的边，其他点都有。所以使用邻接表或者tree的结构，时间复杂度是 O(n) 快速排序采用Partition操作，复杂度是TreeHight * N，在树的每一层的parition操作中，都要有N次遍历操作。 最理想情况下，即每次partition都在中间位置划分，则树的高度是log(n)，最坏的情况则是树高趋于N。 LeetCode有一个关于快速排序的题目(SortList)，其中的一个测试用例包含大量的重复数字。而代码默认没有优化的话，这种情况下会很糟糕。 可以针对这种情况进行优化，在Partition的过程中将选定的PartitionValue的重复项都位于中间，返回两个partition点，如下面两端的5。然后剩下仅对左右两个部分进行运算即可。 121 2 4 2 1 | 5 5 5 5 5 5 5 | 7 8 9 - -","categories":[{"name":"算法","slug":"算法","permalink":"http://xiaoningliu.com/categories/算法/"}],"tags":[{"name":"复杂度","slug":"复杂度","permalink":"http://xiaoningliu.com/tags/复杂度/"},{"name":"面试","slug":"面试","permalink":"http://xiaoningliu.com/tags/面试/"},{"name":"备忘","slug":"备忘","permalink":"http://xiaoningliu.com/tags/备忘/"},{"name":"算法","slug":"算法","permalink":"http://xiaoningliu.com/tags/算法/"}]},{"title":"Linux快速笔记","slug":"Linux快速笔记","date":"2016-03-15T15:19:29.000Z","updated":"2017-01-07T17:06:00.000Z","comments":true,"path":"2016/03/15/Linux快速笔记/","link":"","permalink":"http://xiaoningliu.com/2016/03/15/Linux快速笔记/","excerpt":"","text":"Linux快速笔记 ln -s source linkName 建立软链接，-s 是symbolic link的意思，很多时候可能会认不清source和linkName的顺序，这时候可以把-s 当做”source”的意思。 chown -R git:git folder 设置一堆文件的所有者，比如服务器apache的www目录，要给www用户相应的权限。 chmod -R 777 foder 设置一堆文件的权限，比如.ssh中保存的authorized_keys文件；7代表二进制的111，分别代表读、写以及执行。 ls -lh 相当于ll tail -f file 持续查看文件结尾 which 定位可执行文件位置 12alias &apos;ll=ls -hl&apos;`alias 查看或设置命令别名 locate php.ini 快速定位文件，尤其是配置文件 grep 快速文本朝找命令 awk &#39;{print $1}&#39; 按照分隔符分割每一行字符串并输出，默认分隔符是空格与TAB scp -r /path/filename username@servername:/path -p 22 命令中服务器路径和本地路径可以交换 tar 解压：tar -x(必有，代表解压; c 代表压缩)z(代表gzip格式; j refers to bz2)v(可选，输出信息)f(必有，选择被解压文件) file.tar.gz unzip xxx.zip -d newfolder zip解压缩 netstat -t(tcp)u(udp)n(number)p(program name)l(listen) netstat -l(listening or a refers to all)t(tcp or u refers to udp)p(program)netstat -n(using number format for ip)e(extend info)t(tcp) find /folder -name fileName [-type f] 搜索文件 wc -l find /folder -type f -name fileName [-maxdepth 0] | wc -l #文件数量 file return file type, x64 etc. history 命令操作历史 last 用户登录历史 env env | grep ORACLE uname -a 查看系统信息 ps -ef(every process) | grep xxx 查看进程 fdisk -l 查看所有可用于挂载的磁盘 fdisk /dev/xvdb 为这个磁盘建立分区表（注意：每个物理盘需要先在第一个sector建立分区表，然后每个分区进行格式化，然后挂载使用）这个命令结束后，硬盘“/dev/xvdb”会变成几个分区”/dev/xvdb1 …” df -h 查看磁盘挂载情况，磁盘使用率 du -h --max-depth=1 /folder_path 查看文件夹大小 du -sh /folder 查看仅指定文件夹大小 mount -t vfat /dev/XXX /folder 挂载需提前创建目标目录 Linux常用目录cat /etc/issue 查看系统版本 /etc/ssh/sshd_config 修改服务器ssh端口号 /etc/hosts hosts /etc/hostname hostname // command /etc/network/interfaces 修改网络配置 /etc/resolv.conf nameserver 202.96.128.86 /etc/init.d/network restart /etc/issue 系统版本号 /etc/passwd 用户列表以及登陆shell设置","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xiaoningliu.com/categories/Linux/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://xiaoningliu.com/tags/面试/"},{"name":"Linux","slug":"Linux","permalink":"http://xiaoningliu.com/tags/Linux/"},{"name":"笔记","slug":"笔记","permalink":"http://xiaoningliu.com/tags/笔记/"},{"name":"备忘","slug":"备忘","permalink":"http://xiaoningliu.com/tags/备忘/"}]},{"title":"C/C++检查文件大小","slug":"C_CPP文件大小","date":"2016-03-15T05:49:08.000Z","updated":"2016-03-15T06:11:35.000Z","comments":true,"path":"2016/03/15/C_CPP文件大小/","link":"","permalink":"http://xiaoningliu.com/2016/03/15/C_CPP文件大小/","excerpt":"","text":"C/C++检查文件大小 今天V2EX社区有伙伴贴出了面试阿里后端的内容，其中涉及使用C获取文件大小的问题。因为本人对C++比较熟悉，将可以使用C++风格的两种方式总结如下： 备注：以下代码均为C++实现 C++使用ifstream查看12345678910#include &lt;fstream&gt;using namespace std;ifstream i(\"file\");if (i.is_open())&#123; i.seekg(0, i.end); // i.end是枚举类型 cout&lt;&lt;\"c++ length:\"&lt;&lt;i.tellg()&lt;&lt;endl;&#125;i.close(); 重点函数有两个，平时可能不太常用，函数还有其他的重载实现，但在本例子中只用了以下两种实现： seekg(0, i.end) tellg() C++使用C代码库查看1234567#include &lt;cstdio&gt;using namespace std;FILE *f = fopen(\"file\", \"r\");fseek(f, 0, SEEK_END);cout&lt;&lt;\"c length: \"&lt;&lt;ftell(f)&lt;&lt;endl;;fclose(f); 本例子中重点使用以下函数与命令： FILE *f = fopen(xx, xx) fseek(f, 0, SEEK_END) ftell() Linux使用Shell命令查看1ls -lh | grep XXX | awk &apos;&#123;print $x&#125;&apos; 备注在C下面还有使用struct _stat结构体获取文件大小的办法，具体请参考相关资料。 相关资料 AWK 命令的使用方式 C语言获取文件大小两种办法","categories":[{"name":"C++","slug":"C","permalink":"http://xiaoningliu.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://xiaoningliu.com/tags/C/"},{"name":"面试","slug":"面试","permalink":"http://xiaoningliu.com/tags/面试/"},{"name":"C","slug":"C","permalink":"http://xiaoningliu.com/tags/C/"},{"name":"文件","slug":"文件","permalink":"http://xiaoningliu.com/tags/文件/"}]},{"title":"程序员健康指南之游泳","slug":"2016-3-14-游泳小记","date":"2016-03-14T12:30:46.000Z","updated":"2016-03-14T13:38:02.000Z","comments":true,"path":"2016/03/14/2016-3-14-游泳小记/","link":"","permalink":"http://xiaoningliu.com/2016/03/14/2016-3-14-游泳小记/","excerpt":"","text":"程序员健康指南之游泳 1在水中游动，闭上眼睛，仿佛在飞翔 游泳与中断优先级今天恢复了寒假中断3个月的游泳，然而不像CPU处理中断一样，对于运动来说坚持往往比为赶进度激烈的偶尔运动要好很多。即存在以下大小关系： 1坚持游泳 + 适当运动量 &gt; 偶尔游泳 &gt; 偶尔激烈游泳 &gt; 不游泳 中断原因游泳和很多运动都是需要坚持，而坚持的前提是拥有足够的时间。从学会游泳到现在已接近两年，最初想的是以后必经常游泳，从此屌丝变型男，迎娶白富美。 但是，在程序员的世界中，码代码等优先级往往比游泳来的更高。因此一旦连续几天被代码延误了运动，便会把游泳的习惯打破，从而逐渐放弃。 因此，针对这种现象，我曾经调整过自身事件的优先级。将游泳的优先级调整大于每日代码。即，每天到时间必定去游泳。 然而，此种策略执行一周便宣告失败。因为，虽然能坚持去游泳。但拖延代码工作带来的压力会逐渐的积累，直到超过游泳带来的成就感。所以不能制定这种策略。 程序员游泳建议配合休息如果平时睡眠不足，过度疲劳，如果想通过游泳等运动改善，往往会适得其反。 运动改善机体机能的原理是通过大量消耗身体能量刺激身体变得强壮，而这一刺激过程需要身体先损耗，然后通过休息得到强壮。 如果身体本身很疲劳，第一件事情要做的是多喝水、多睡觉，而不是去锻炼。 而且，一旦参加锻炼，便要在当天注意补充休息和能量，比如水果等。 为游泳制造条件通常情况下，正常工作的优先级无疑是大于游泳的。在此种前提下，要保证游泳的正常进行的唯一办法，则是高效率完成代码工作，为游泳留出时间与条件。 在这种情况下，游泳一方面能刺激正常工作的高效率完成，另一方面也从身体机能的提高上面促进了正常工作的效率。","categories":[{"name":"程序员健康指南","slug":"程序员健康指南","permalink":"http://xiaoningliu.com/categories/程序员健康指南/"}],"tags":[{"name":"游泳","slug":"游泳","permalink":"http://xiaoningliu.com/tags/游泳/"},{"name":"程序员","slug":"程序员","permalink":"http://xiaoningliu.com/tags/程序员/"},{"name":"运动","slug":"运动","permalink":"http://xiaoningliu.com/tags/运动/"},{"name":"健康","slug":"健康","permalink":"http://xiaoningliu.com/tags/健康/"}]},{"title":"读书笔记 遇见未知的自己 前言","slug":"2015-3-9-读书笔记-遇见未知的自己-一","date":"2016-03-11T15:20:04.000Z","updated":"2016-03-11T15:20:04.000Z","comments":true,"path":"2016/03/11/2015-3-9-读书笔记-遇见未知的自己-一/","link":"","permalink":"http://xiaoningliu.com/2016/03/11/2015-3-9-读书笔记-遇见未知的自己-一/","excerpt":"","text":"读书笔记 遇见未知的自己 前言2015年03月09日鸡汤不好喝不知从什么时候，心灵鸡汤一类的书越来越不受欢迎，也好像是形成了一种风潮，看到朋友圈、微博上别人转发的”永远要保持奋斗”,”成功职场必备的XX技能”此类励志贴,如果不嗤之以鼻就显示不出自己的品味或高尚。或者也会对家里的老爸老妈好言相劝，让其不要用此类帖子来刷自己的屏。 甚至在以高素质著称的的知识分享平台“知乎“上，有人提到这个问题“为什么心灵鸡汤如此的不受欢迎？”受到很多人的热议。 在以理性著称的知乎中是很少出现集体吐槽现象的，然而，但在这个条目下的回答与评论中，充斥的是对市面上的励志书籍、书店里的心灵鸡汤、微博朋友圈中的技能总结帖万分的”恶意“。 那么为什么会产生这种现象呢？ 让我们来看看下面这匹马。 如何画好一匹马先回到上面所说的知乎问题，其中得到大家最多赞同的是下面这副来自“走刀口”回答中的图片。 是的，人们是一种很奇怪的所在。当天寒地冻，身无分文，买不起一碗饭的时候，最需要的是别人的一碗热汤；当遇到挫折、心灰意冷的时候，最需要的是他人的鼓励与支持；但当人衣食无忧满怀信心的去做事情的时候，最需要的不是再给更多的汤或者激励，这时候需要的是方法的指点。 所以，人们并不傻，鸡汤是鸡汤不是不能，但也不是全能。很多人之所以厌恶鸡汤： 一方面是真心厌恶一些低质鸡汤书中的假大空，忽略智商甚至常识，毫无实质，让人望梅止渴 而另一方面，则是对自己浑浑噩噩的生活的逃避，失去思考的能力，不去判断鸡汤中哪些是正确，只留下一味批判 有些则是对自己毫无执行力，而他人能坚持如一的愤懑与嫉妒 真的，很多人失去了判断与思考的习惯，留下了一身吐槽的戾气。也有一些人，有了动力，有了方法，却无法做到，责备鸡汤只是一个借口罢了。 我的鸡汤我的第一本鸡汤是李开复先生的《做最好的自己》。说起来很好笑，当时是怀着在书店找一本作文素材书的目的漫无目的的乱翻，却一眼看到了李开复先生硕大的头像，突然想起李是名人，用作素材铁定拿高分，于是便屁颠屁颠的买下来，却一见杨过毁终身，误入了鸡汤的大门，那是我的第一本鸡汤书。 我所在的高中是一所省重点高中，却饱含着向衡水中学(以精确到分的严格要求的中学)学习的理念，毫不留情的压榨大家的时间，也增添着学生的压力。李在书中第一章节便花费了大量的篇幅，阐述什么是成功，以此作为基石，提供了很多切实可行的提高办法。在当时，甚至每场考试之前，都会回想起李先生书中的话，以此作为激励，受益颇多。可惜的是，迄今为止，很多有益的事情至今没有完全做到。 上了大学，也看过隔壁寝室同学推销的李彦宏先生的《人生可以走直线》，路边大妈成捆卖的《大学应该做什么》…… 直到看到上面知乎的回答中的那匹马。 一般的鸡汤是告诉你，你可以，你能行！相信自己！你可以成功！！这能提供一段时间高昂的斗志。 好些的鸡汤是告诉你，你可以，你能行！更重要的是告诉你，应该怎样去行。这能教会行事的具体办法与道路。 上好的鸡汤是让你思考，什么是行，人生是什么，要追求什么。这能提供人们坚持下去根本的动力。 所以直至现在，我依然认为李开复先生的这本书是鸡汤中的上好书，既有动力也有方法。只是其并不完美（这和李先生本人做事的风格性格相关），我觉得在其理论的最核心之处应该增加一条——“好的身体”，愿李先生身体健康。 遇见未知的自己也许在一些朋友眼中，这本书不应当算是鸡汤书，我以为，只能在精神思想层面给人带来帮助的书籍均可算作鸡汤书。那么这次读的是朋友推荐的一本书，《遇见未知的自己》。偶有所获，与大家分享。 这本书与寻常的鸡汤书不同，没有大段的例子，没有不得意的任务。整篇行文就像一篇小时候妈妈讲述的故事，又像一篇幽静的小说。只需静静的去读与思考。","categories":[{"name":"读书","slug":"读书","permalink":"http://xiaoningliu.com/categories/读书/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2016-03-10T16:00:00.000Z","updated":"2016-06-18T11:55:48.000Z","comments":true,"path":"2016/03/11/hello-world/","link":"","permalink":"http://xiaoningliu.com/2016/03/11/hello-world/","excerpt":"","text":"大家好，我是刘晓宁，这是我的新博客的开篇内容。这篇内容是由Hexo框架自动生成的Hello World，这里也作为本博客的起始。 一直想将个人博客正规起来，却一直没有动手。在我看来，博客应该是作为个人将消化整理并证明正确的知识传播的平台。而我的很多总结大多记录在Evernote这个笔记应用中，也就是为己用。要做到放到博客重，给大家使用还有一段距离。在接下来的一个月时间内，我会集中整理几年的笔记并竭力保证正确性。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a New Post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"思考","slug":"思考","permalink":"http://xiaoningliu.com/categories/思考/"}],"tags":[]}]}